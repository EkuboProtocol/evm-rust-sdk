use crate::math::muldiv::muldiv;
use crate::math::uint::U256;
use num_traits::Zero;

const TWO_POW_128: U256 = U256([0, 0, 1, 0]);

pub fn exp(x: u128) -> Option<U256> {
    if x < 0x20000000000000000 {
        Some(exp_inner(x))
    } else {
        let half = exp(x >> 1)?;

        muldiv(half, half, TWO_POW_128, false).ok()
    }
}

const STARTING_VALUE: U256 = U256([0, 18446744073709551615, 0, 0]);

// Constants corresponding to each bit position from 1 to 56
const MASKS: [U256; 56] = [
    U256([2, 18446744073709551614, 0, 0]), U256([8, 18446744073709551612, 0, 0]), U256([32, 18446744073709551608, 0, 0]), U256([128, 18446744073709551600, 0, 0]), U256([512, 18446744073709551584, 0, 0]), U256([2048, 18446744073709551552, 0, 0]), U256([8192, 18446744073709551488, 0, 0]), U256([32768, 18446744073709551360, 0, 0]), U256([131072, 18446744073709551104, 0, 0]), U256([524288, 18446744073709550592, 0, 0]), U256([2097152, 18446744073709549568, 0, 0]), U256([8388608, 18446744073709547520, 0, 0]), U256([33554432, 18446744073709543424, 0, 0]), U256([134217728, 18446744073709535232, 0, 0]), U256([536870912, 18446744073709518848, 0, 0]), U256([2147483648, 18446744073709486080, 0, 0]), U256([8589934592, 18446744073709420544, 0, 0]), U256([34359738368, 18446744073709289472, 0, 0]), U256([137438953472, 18446744073709027328, 0, 0]), U256([549755813888, 18446744073708503040, 0, 0]), U256([2199023255552, 18446744073707454464, 0, 0]), U256([8796093022207, 18446744073705357312, 0, 0]), U256([35184372088827, 18446744073701163008, 0, 0]), U256([140737488355285, 18446744073692774400, 0, 0]), U256([18446744067982928555, 18446744065119617025, 0, 0]), U256([18446744027896567136, 18446744056529682439, 0, 0]), U256([18446743707205675861, 18446744039349813279, 0, 0]), U256([18446741141678546944, 18446744004990075007, 0, 0]), U256([18446720617461536085, 18446743936270598655, 0, 0]), U256([18446556423725776896, 18446743798831646719, 0, 0]), U256([18445242873844946261, 18446743523953745919, 0, 0]), U256([18434734474882187262, 18446742974197956607, 0, 0]), U256([18350667284522292497, 18446741874686427135, 0, 0]), U256([17678129783117969271, 18446739675663564799, 0, 0]), U256([12297830115480716356, 18446735277618626559, 0, 0]), U256([6148926419358309854, 18446726481531895805, 0, 0]), U256([12298017032385925416, 18446708889371017194, 0, 0]), U256([6151917088697449768, 18446673705099591509, 0, 0]), U256([12345867705197637723, 18446603336758065834, 0, 0]), U256([6917526682022241153, 18446462600880313685, 0, 0]), U256([6148839631624500903, 18446181132345977515, 0, 0]), U256([18444342178341666037, 18445618208161748319, 0, 0]), U256([6072054821318662137, 18444492411329227605, 0, 0]), U256([15987278273716257493, 18442241023793258495, 0, 0]), U256([1236187610958932316, 18437739073120195921, 0, 0]), U256([9018351032227130592, 18428738468430479223, 0, 0]), U256([12700438678773232781, 18410750438167364677, 0, 0]), U256([15460585676577230399, 18374827034086858296, 0, 0]), U256([18329520299923743087, 18303190372430456779, 0, 0]), U256([16755060404583585059, 18160753814917686419, 0, 0]), U256([6342580978842835689, 17879197424118840458, 0, 0]), U256([17406395174995385727, 17329112349219823218, 0, 0]), U256([4517434366365616891, 16279194507819420732, 0, 0]), U256([4709846694486406073, 14366338729722795843, 0, 0]), U256([15453437282678069096, 11188515852577165299, 0, 0]), U256([13465419299465525518, 6786177901268885274, 0, 0])
];

fn exp_inner(x: u128) -> U256 {
    assert!(x < 0x20000000000000000, "Invalid input");

    let mut ratio = U256([0, 0, 1, 0]);

    // Handle the first bit separately
    if !(x & 1).is_zero() {
        ratio = STARTING_VALUE;
    }

    for (i, constant) in MASKS.iter().enumerate() {
        let bitmask = 2u128 << i;
        if !(x & bitmask).is_zero() {
            ratio = (ratio * constant) >> 128u8;
        }
    }

    if !x.is_zero() {
        ratio = U256::MAX / ratio;
    }

    ratio
}


#[cfg(test)]
mod tests {
    use super::*;
    use alloc::vec;

    #[test]
    fn test_exp_cases() {
        let cases = vec![
            (
                1u128,
                U256::from_dec_str("340282366920938463481821351505477763073").unwrap(),
            ),
            (
                0x10u128,
                U256::from_dec_str("340282366920938463758522512611121037439").unwrap(),
            ),
            (
                0x100u128,
                U256::from_dec_str("340282366920938468185741090301413457919").unwrap(),
            ),
            (
                0x1000u128,
                U256::from_dec_str("340282366920938539021238333346100019199").unwrap(),
            ),
            (
                0x10000u128,
                U256::from_dec_str("340282366920939672389194222063090401279").unwrap(),
            ),
            (
                0x100000u128,
                U256::from_dec_str("340282366920957806276488442048319324159").unwrap(),
            ),
            (
                0x1000000u128,
                U256::from_dec_str("340282366921247948473196093237981347883").unwrap(),
            ),
            (
                0x10000000u128,
                U256::from_dec_str("340282366925890223620552157328383847083").unwrap(),
            ),
            (
                0x100000000u128,
                U256::from_dec_str("340282367000166625986862317062882765483").unwrap(),
            ),
            (
                1u128 << 64, // 1 << 64
                U256::from_dec_str("924983374546220337150911035843336795078").unwrap(),
            ),
            (
                0x20000000000000000u128, // 0x20000000000000000
                U256::from_dec_str("2514365498655717699434277416465328696985").unwrap(),
            ),
            (
                88u128 << 64, // 88 << 64
                U256::from_dec_str("56202269414179362208214868742863362868341779313762687677660940959816606662721").unwrap(),
            ),
        ];

        for (x, expected) in cases {
            let result = exp(x).unwrap();
            assert_eq!(
                result, expected,
                "exp({:?}) failed. Expected {:?}, got {:?}",
                x, expected, result
            );
        }
    }
}

